URL: https://tonybaloney.github.io/CSnakes/
CSnakes Skip to content CSnakes Home Initializing search GitHub CSnakes GitHub Home Home Table of contents Features Benefits Example Getting Started Reference Environment and Package Management Asynchronous Functions Performance Considerations Buffer Protocol and NumPy Arrays Advanced Usage Limitations FAQ Examples Table of contents Features Benefits Example CSnakes - a tool for embedding Python code into .NET projects CSnakes is a .NET Source Generator and Runtime that you can use to embed Python code and libraries into your C#.NET Solution at a performant, low-level without the need for REST, HTTP, or Microservices. Check out the getting started guide or check out the demo solution to see more. Features Supports .NET 8 and 9 Supports Python 3.9-3.13 Supports Virtual Environments and C-Extensions Supports Windows, macOS, and Linux Tight integration between NumPy ndarrays and Spans, 2D Spans and TensorSpans (.NET 9) Uses Python's C-API for fast invocation of Python code directly in the .NET process Uses Python type hinting to generate function signatures with .NET native types Supports CPython 3.13 "free-threading" mode Supports nested sequence and mapping types ( tuple , dict , list ) Supports default values Supports Hot Reload of Python code in Visual Studio and supported IDEs Supports UV for fast installation of Python packages and dependencies Benefits Uses native Python type hinting standards to produce clean, readable C# code with minimal boiler plate! Integration between .NET and Python is done at the C-API, meaning strong compatibility between Python versions 3.8-3.13 and .NET 8-9. Integration is low-level and high-performance. CSnakes uses the CPython C-API and is compatible with all Python extensions. Invocation of Python code and libraries is in the same process as .NET Example CSnakes will generate a C#.NET class for any Python file in a project that is tagged as CSharp Analyzer Additional File (see Getting Started ).
All functions in that class with type annotations will be reflected to callable C# methods and an environment builder added to that module. Made with Material for MkDocs


URL: https://tonybaloney.github.io/CSnakes/advanced/
Advanced Usage - CSnakes Skip to content CSnakes Advanced Usage Initializing search GitHub CSnakes GitHub Home Getting Started Reference Environment and Package Management Asynchronous Functions Performance Considerations Buffer Protocol and NumPy Arrays Advanced Usage Advanced Usage Table of contents Handling very large integers Free-Threading Mode Calling Python without the Source Generator Disabling the Source Generator Hot Reload Limitations Disabling Signal Handlers in Python Limitations FAQ Examples Table of contents Handling very large integers Free-Threading Mode Calling Python without the Source Generator Disabling the Source Generator Hot Reload Limitations Disabling Signal Handlers in Python Advanced Usage Handling very large integers Python's int type is closer in structure to C#.NET's System.Numerics.BigInteger than to System.Int64 . This means that when you are working with very large integers in Python, you may need to use the BigInteger type in C# to handle the results. You can use this using the TypeConverter class to convert between BigInteger and PyObject instances. Here's an example of how you can call a Python function that returns a very large integer: using CSnakes.Runtime.Python ; using System.Numerics ; const string number = "12345678987654345678764345678987654345678765" ; // Something that is too big for a long (I8) BigInteger bignumber = BigInteger . Parse ( number ); using ( GIL . Acquire ()) { using PyObject ? pyObj = PyObject . From ( bignumber ); // Do stuff with the integer object // e.g. call a function with this as an argument // Convert a Python int back into a BigInteger like this.. BigInteger integer = pyObj . As < BigInteger > (); } Free-Threading Mode Python 3.13 introduced a new feature called "free-threading mode" which allows the Python interpreter to run in a multi-threaded environment without the Global Interpreter Lock (GIL). This is a significant change to the Python runtime and can have a big impact on the performance of Python code running in a multi-threaded environment. CSnakes supports free-threading mode, but it is disabled by default. To use free-threading you can use the RedistributableLocator from version Python 3.13 and request freeThreaded builds: var builder = Host . CreateApplicationBuilder (); var pb = builder . Services . WithPython () . WithHome ( Environment . CurrentDirectory ) // Path to your Python modules. . FromRedistributable ( "3.13" , freeThreaded : true ); var app = builder . Build (); env = app . Services . GetRequiredService < IPythonEnvironment > (); Whilst free-threading mode is supported at a high-level from CSnakes, it is still an experimental feature in Python 3.13 and may not be suitable for all use-cases. Also, most Python libraries, especially those written in C, are not yet compatible with free-threading mode, so you may need to test your code carefully. Calling Python without the Source Generator The Source Generator library is a useful tool for creating the boilerplate code to invoke a Python function from a PythonEnvironment instance and convert the types based on the type annotations in the Python function. It is still possible to call Python code without the Source Generator, but you will need to write the boilerplate code yourself. Here's an example of how you can call a Python function without the Source Generator to call a Python function in a module called test_basic : def test_int_float ( a : int , b : float ) -> float : return a + b The C# code to call this function needs to: Convert the .NET types to PyObject instances and back. Use the GIL.Acquire() method to acquire the Global Interpreter Lock for all conversions and calls to Python. Use the Import.ImportModule method to import the module and store a reference once so that it can be used multiple times. Dispose the module when it is no longer needed. using CSnakes.Runtime ; using CSnakes.Runtime.Python ; using System ; using System.Collections.Generic ; using System.Diagnostics ; using Microsoft.Extensions.Logging ; namespace CSnakes.Runtime ; public sealed class ExampleDirectIntegration : IDisposable { private readonly PyObject module ; private readonly ILogger < IPythonEnvironment > logger ; internal TestBasicInternal ( IPythonEnvironment env ) { this . logger = env . Logger ; using ( GIL . Acquire ()) { logger . LogInformation ( "Importing module {ModuleName}" , "test_basic" ); module = Import . ImportModule ( "test_basic" ); } } public void Dispose () { logger . LogInformation ( "Disposing module" ); module . Dispose (); } public double TestIntFloat ( long a , double b ) { using ( GIL . Acquire ()) { logger . LogInformation ( "Invoking Python function: {FunctionName}" , "test_int_float" ); using var __underlyingPythonFunc = this . module . GetAttr ( "test_int_float" ); using PyObject a_pyObject = PyObject . From ( a ); using PyObject b_pyObject = PyObject . From ( b ); using var __result_pyObject = __underlyingPythonFunc . Call ( a_pyObject , b_pyObject ); return __result_pyObject . As < double > (); } } } Disabling the Source Generator The Source Generator will only activate on files that are marked as AdditionalFiles in the project file. If you want to disable the Source Generator, you can remove the AdditionalFiles entry from the project file. Alternatively , you can disable the Source Generator by setting the DisableCSnakesRuntimeSourceGenerator property in the project file: <DisableCSnakesRuntimeSourceGenerator> true </DisableCSnakesRuntimeSourceGenerator> Hot Reload CSnakes supports hot reload of Python code in Visual Studio and supported IDEs. 
This means that you can make changes to your Python code within the function body and see the changes reflected in your C# code without restarting the application. This feature is enabled in the generated classes in CSnakes. When you make changes to the Python code, the modules are reloaded in the .NET runtime and subsequent calls to the Python code will use the new code. To enable Hot Reload, see the VS 2022 documentation. Limitations Beyond the C# limitations , Hot Reload would not support changes to the Python code which require additional changes to the C# such as : Removing functions Changing function signatures Changing the return type of a function Changing the type of a function argument Changing the name of a function Changing the name of a module The Hot Reload feature is useful for iterating on the body of a Python function, without having to restart the debugger or application. Disabling Signal Handlers in Python By default, Python will install signal handlers for certain signals, such as SIGINT (Ctrl+C) and SIGTERM . This can interfere with the normal operation of your application, especially if you are using a framework that has its own signal handlers.
This means that signal handlers on C# code will not be called when the signal is received, and the Python code will handle the signal instead. You can disable this behavior by using the .DisableSignalHandlers() method on the IPythonEnvironment instance: var builder = Host . CreateApplicationBuilder (); var pb = builder . Services . WithPython () . WithHome ( Environment . CurrentDirectory ) . FromRedistributable () . DisableSignalHandlers (); // Disable Python signal handlers var app = builder . Build (); env = app . Services . GetRequiredService < IPythonEnvironment > (); Made with Material for MkDocs


URL: https://tonybaloney.github.io/CSnakes/async_support/
Asynchronous Functions - CSnakes Skip to content CSnakes Asynchronous Functions Initializing search GitHub CSnakes GitHub Home Getting Started Reference Environment and Package Management Asynchronous Functions Asynchronous Functions Table of contents Implementation Details Parallelism considerations Performance Considerations Buffer Protocol and NumPy Arrays Advanced Usage Limitations FAQ Examples Table of contents Implementation Details Parallelism considerations Async support Python async functions will be generated into async C# methods. The generated C# method will return a Task<T> depending on the return type of the Python function. import asyncio async def async_function () -> int : await asyncio . sleep ( 1 ) return 42 The generated C# method will have this signature: public async Task < int > AsyncFunction ( CancellationToken cancellationToken = default ); Python async functions can be awaited in C# code. Implementation Details The C# Async model and the Python Async models have some important differences: C# creates a task pool and tasks are scheduled on this pool. Python uses a single-threaded event loop. Python event loops belong to the thread that created them. C# tasks can be scheduled on any thread. Python async functions are coroutines that are scheduled on the event loop. C# async functions are tasks that are scheduled on the task pool. To converge these two models, CSnakes creates a Python event-loop for each C# thread that calls into Python. This event loop is created when the first Python function is called and is destroyed when the thread is disposed. This event loop is used to schedule the Python async functions.
Because C# reuses threads in the Task pool, the event loop is reused and kept as a thread-local variable. The behavior is abstracted away from the user, but it is important to understand that the Python event loop is created and destroyed for each C# thread that calls into Python. This is important to understand when debugging or profiling your application. Parallelism considerations Event though C# uses a thread-pool to schedule tasks, the Python Global Interpreter Lock (GIL) will prevent multiple Python threads from running in parallel.
This means that even if you use parallel LINQ or other parallel constructs in C#, CPU-bound Python code will mostly run in a single thread at a time. Python 3.13 and above have a feature called "free-threading mode" which allows the Python interpreter to run in a multi-threaded environment without the Global Interpreter Lock (GIL). This is a significant change to the Python runtime and can have a big impact on the performance of Python code running in a multi-threaded environment.
See Free-Threading Mode for more information. Made with Material for MkDocs


URL: https://tonybaloney.github.io/CSnakes/buffers/
Buffer Protocol and NumPy Arrays - CSnakes Skip to content CSnakes Buffer Protocol and NumPy Arrays Initializing search GitHub CSnakes GitHub Home Getting Started Reference Environment and Package Management Asynchronous Functions Performance Considerations Buffer Protocol and NumPy Arrays Buffer Protocol and NumPy Arrays Table of contents Two-Dimensional Buffers N-dimensional Buffers (.NET 9) NumPy Type Conversion Bytes objects as buffers Handing non-contiguous arrays Advanced Usage Limitations FAQ Examples Table of contents Two-Dimensional Buffers N-dimensional Buffers (.NET 9) NumPy Type Conversion Bytes objects as buffers Handing non-contiguous arrays Buffer Protocol and NumPy Arrays CSnakes supports the Python Buffer Protocol for bytes and bytearray types. The Buffer Protocol is a low-level interface for reading and writing raw bytes from Python objects.
The IPyBuffer interface is used to represent Python objects that support the Buffer Protocol. It has methods for accessing the raw data of the buffer in a Read-Only or Read-Write Span. Since NumPy ndarrays also support the Buffer Protocol, you can use the IPyBuffer interface to efficiently read and write data from NumPy arrays. collections.abc.Buffer was introduced in Python 3.12, but for older versions you can import Buffer from the typing_extensions package on PyPi. For example: try : from collections.abc import Buffer except ImportError : from typing_extensions import Buffer import numpy as np def example_array () -> Buffer : return np . array ([ True , False , True , False , False ], dtype = np . bool_ ) In this example, the example_array function returns a NumPy array of boolean values. The Buffer type hint indicates that the function returns an object that supports the Buffer Protocol. From C#, CSnakes will return an CSnakes.Runtime.Python.IPyBuffer that provides access to the data as a Span . For example: // Where testModule is a Python module that contains the example_array function var bufferObject = testModule . ExampleArray (); // check if the buffer is scalar (single dimensional) if ( bufferObject . IsScalar ) { // Get the buffer contents as a Span of bool Span < bool > result = bufferObject . AsBoolSpan (); Console . WriteLine ( result [ 0 ]); // True Console . WriteLine ( result [ 4 ]); // False } Danger Span is writeable so you can also modify the buffer contents from C# and the changes will be reflected in the Python object.
If you have want a read-only view of the buffer, you can use the As[T]ReadOnly method to get a read-only Span.
We recommend using the read-only methods when you don't need to modify the buffer contents. If you want a read-only view of the buffer, you can use the As[T]ReadOnly method to get a read-only Span. Span < bool > result = bufferObject . AsBoolReadOnlySpan (); Two-Dimensional Buffers The IPyBuffer interface also provides methods for working with two-dimensional buffers. You can use the As[T]Span2D and As[T]ReadOnlySpan2D methods to get a two-dimensional Span of the buffer contents. You can use the Dimensions property to get the dimensions of the buffer. The As[T]Span2D method will throw an exception if the buffer is not two-dimensional. For example: def example_array_2d () -> Buffer : return np . array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]], dtype = np . int32 ) From .NET you can access the buffer as a two-dimensional Span: // Where testModule is a Python module that contains the example_array_2d function var result = testModule . ExampleArray2D (); // Get the buffer contents as a two-dimensional Span of int Span2D < int > result2D = result . AsIntSpan2D (); Console . WriteLine ( result2D [ 0 , 0 ]); // 1 Console . WriteLine ( result2D [ 2 , 3 ]); // 6 N-dimensional Buffers (.NET 9) In .NET 9, the IPyBuffer interface also provides methods for working with N-dimensional buffers using the Experimental System.Numerics.Tensors.TensorSpan type . You can use the AsTensorSpan and AsReadOnlyTensorSpan methods to get a N-dimensional TensorSpan of the buffer contents. For example: def example_tensor () -> Buffer : arr = np . zeros (( 2 , 3 , 4 , 5 ), dtype = np . int32 ) arr [ 0 , 0 , 0 , 0 ] = 1 arr [ 1 , 2 , 3 , 4 ] = 3 return arr From .NET you can access the buffer as a N-dimensional TensorSpan: // Where testModule is a Python module that contains the example_tensor function var result = testModule . ExampleTensor (); // Get the buffer contents as a N-dimensional TensorSpan of int TensorSpan < int > resultTensor = result . AsTensorSpan < int > (); // or AsInt32ReadOnlyTensorSpan Console . WriteLine ( resultTensor [ 0 , 0 , 0 , 0 ]); // 1 Console . WriteLine ( resultTensor [ 1 , 2 , 3 , 4 ]); // 3 NumPy Type Conversion The Numpy dtypes are mapped to C# types as follows: NumPy dtype C# Type Span Method ReadOnly Span Method Span2D Method ReadOnly Span2D Method TensorSpan Method ReadOnly TensorSpan Method bool bool AsBoolSpan AsBoolReadOnlySpan AsBoolSpan2D AsBoolReadOnlySpan2D AsBoolTensorSpan AsBoolReadOnlyTensorSpan int8 sbyte AsSByteSpan AsSByteReadOnlySpan AsSByteSpan2D AsSByteReadOnlySpan2D AsSByteTensorSpan AsSByteReadOnlyTensorSpan int16 short AsInt16Span AsInt16ReadOnlySpan AsInt16Span2D AsInt16ReadOnlySpan2D AsInt16TensorSpan AsInt16ReadOnlyTensorSpan int32 int AsInt32pan AsInt32ReadOnlySpan AsInt32pan2D AsInt32ReadOnlySpan2D AsInt32TensorSpan AsInt32ReadOnlyTensorSpan int64 long AsInt64Span AsInt64ReadOnlySpan AsInt64Span2D AsInt64ReadOnlySpan2D AsInt64TensorSpan AsInt64ReadOnlyTensorSpan uint8 byte AsByteSpan AsByteReadOnlySpan AsByteSpan2D AsByteReadOnlySpan2D AsByteTensorSpan AsByteReadOnlyTensorSpan uint16 ushort AsUInt16Span AsUInt16ReadOnlySpan AsUInt16Span2D AsUInt16ReadOnlySpan2D AsUInt16TensorSpan AsUInt16ReadOnlyTensorSpan uint32 uint AsUInt32Span AsUInt32ReadOnlySpan AsUInt32Span2D AsUInt32ReadOnlySpan2D AsUInt32TensorSpan AsUInt32ReadOnlyTensorSpan uint64 ulong AsUInt64Span AsUInt64ReadOnlySpan AsUInt64Span2D AsUInt64ReadOnlySpan2D AsUInt64TensorSpan AsUInt64ReadOnlyTensorSpan float32 float AsFloatSpan AsFloatReadOnlySpan AsFloatSpan2D AsFloatReadOnlySpan2D AsFloatTensorSpan AsFloatReadOnlyTensorSpan float64 double AsDoubleSpan AsDoubleReadOnlySpan AsDoubleSpan2D AsDoubleReadOnlySpan2D AsDoubleTensorSpan AsDoubleReadOnlyTensorSpan The GetItemType() method can be used to get the C# type of the buffer contents. You can also use generic methods such as AsSpan<T> and AsReadOnlySpan<T> to get a Span of the buffer contents with the specified type. If the requested type does not match the buffer contents, an exception will be thrown. Bytes objects as buffers In addition to NumPy arrays, you can also use bytes and bytearray objects as buffers. The Buffer type hint can be used to indicate that a function returns a bytes or bytearray object that supports the Buffer Protocol. The Buffer Protocol is an efficient way to read and write bytes between C# and Python. Use AsByteSpan and AsByteReadOnlySpan to access the raw bytes of the buffer. Handing non-contiguous arrays If the NumPy array is not C-contiguous, the Buffer conversion throw an exception. This will happen for example when you transpose a NumPy array. To convert a Fortran-contiguous array to a C-contiguous array, you can use the np.ascontiguousarray() function in Python before returning the array to C#. Made with Material for MkDocs


URL: https://tonybaloney.github.io/CSnakes/environments/
Environment and Package Management - CSnakes Skip to content CSnakes Environment and Package Management Initializing search GitHub CSnakes GitHub Home Getting Started Reference Environment and Package Management Environment and Package Management Table of contents Virtual Environments with venv Disabling automatic environment creation Virtual Environments with conda Installing dependencies with pip Installing dependencies with uv Installing packages at runtime Asynchronous Functions Performance Considerations Buffer Protocol and NumPy Arrays Advanced Usage Limitations FAQ Examples Table of contents Virtual Environments with venv Disabling automatic environment creation Virtual Environments with conda Installing dependencies with pip Installing dependencies with uv Installing packages at runtime Environment and Package Management CSnakes comes with support for executing Python within a virtual environment and the specification of dependencies. There are two main package management solutions for Python, pip and conda . pip is the default package manager for Python and is included with the Python installation. conda is a package manager that is included with the Anaconda distribution of Python. Both package managers can be used to install packages and manage dependencies. There are various ways to create "virtual" environments in Python, where the dependencies are isolated from the system Python installation. The most common way is to use the venv module that is included with Python. The venv module is used to create virtual environments and manage dependencies. Virtual Environment creation and package management are separate concerns in Python, but some tools (like conda) combine them into a single workflow. CSnakes separates these concerns to give you more flexibility in managing your Python environments. Virtual Environments with venv Use the .WithVirtualEnvironment(path) method to specify the path to the virtual environment. You can also optionally use the .WithPipInstaller() method to install packages listed in a requirements.txt file in the virtual environment. If you don't use this method, you need to install the packages manually before running the application. ... services . WithPython () . WithVirtualEnvironment ( Path . Join ( home , ".venv" )) // Python locators . WithPipInstaller (); // Optional - installs packages listed in requirements.txt on startup Disabling automatic environment creation Virtual Environments with conda To use the conda package manager, you need to specify the path to the conda executable and the name of the environment you want to use: Add the FromConda() extension method the host builder. Use the .WithCondaEnvironment(name) method to specify the name of the environment you want to use. ... services . WithPython () . FromConda ( condaBinPath ) . WithCondaEnvironment ( "name_of_environment" ); The Conda Environment manager doesn't currently support automatic creation of environments or installing packages from an environment.yml file, so you need to create the environment and install the packages manually before running the application, by using conda env create -n name_of_environment -f environment.yml Installing dependencies with pip If you want to install dependencies using pip , you can use the .WithPipInstaller() method. This method will install the packages listed in a requirements.txt file in the virtual environment. ... services . WithPython () . WithVirtualEnvironment ( Path . Join ( home , ".venv" )) . WithPipInstaller (); // Optional - installs packages listed in requirements.txt on startup .WithPipInstaller() takes an optional argument that specifies the path to the requirements.txt file. If you don't specify a path, it will look for a requirements.txt file in the virtual environment directory. Installing dependencies with uv uv is an alternative to pip that can also install requirements from a file like requirements.txt or pyproject.toml . UV has a major benefit in a 10-100x speedup over pip, so your CSnakes applications will be faster to start. To use uv to install packages: ... services . WithPython () . WithVirtualEnvironment ( Path . Join ( home , ".venv" )) . WithUvInstaller ( "requirements.txt" ); // Optional - give the name of the requirements file, or pyproject.toml Some other important notes about this implementation. Only uses uv to install packages and does not use uv to create projects or virtual environments. Must be used with WithVirtualEnvironment() , as pip requires a virtual environment to install packages into. Will use the UV_CACHE_DIR environment variable to cache the packages in a directory if set. Will disable the cache if the UV_NO_CACHE environment variable is set. Installing packages at runtime You can resolve the IPythonPackageInstaller service to install packages in the virtual environment. This is useful if you want to install a package at runtime without having to modify the requirements.txt file. services // As existing (see above examples) . WithPython () . WithVirtualEnvironment ( Path . Join ( home , ".venv" )) . WithPipInstaller (); // Optional - installs packages listed in requirements.txt on startup // Environment/host builder setup var installer = serviceProvider . GetRequiredService < IPythonPackageInstaller > (); await installer . InstallPackage ( "attrs==25.3.0" ); This requires both an environment manager (UV or venv) and a package installer to be set up, as it uses the same mechanisms to install packages. Optionally, you can install multiple packages at once by passing a list of package names: await installer . InstallPackages ( new [] { "attrs==25.3.0" , "requests==2.31.0" }); Or, if the package names are in a file, you can use: await installer . InstallPackagesFromRequirements ( "requirements.txt" ); Made with Material for MkDocs


URL: https://tonybaloney.github.io/CSnakes/examples/
Examples - CSnakes Skip to content CSnakes Examples Initializing search GitHub CSnakes GitHub Home Getting Started Reference Environment and Package Management Asynchronous Functions Performance Considerations Buffer Protocol and NumPy Arrays Advanced Usage Limitations FAQ Examples Examples Table of contents Most Basic Example KMeans Example Phi-3 inference demo Embedding Python in a .NET Web App Table of contents Most Basic Example KMeans Example Phi-3 inference demo Embedding Python in a .NET Web App Example Solutions Most Basic Example In the sample solution, the file hello_world.py demonstrates the most basic example of embedding Python code into a .NET project. The Python file contains a single function hello_world that takes a single argument name and returns a greeting message. It takes an optional int of the maximum length of the greeting message, which defaults to 50. def format_name ( name : str , max_length : int = 50 ) -> str : return "Hello {} " . format ( name . capitalize ())[: max_length ] This demo generates the following C# method signature: public string FormatName ( string name , long maxLength = 50 ); KMeans Example A more complex example is the kmeans_example.py file, which contains a function calculate_kmeans_inertia that calculates the inertia of a KMeans clustering algorithm using the sklearn library: from sklearn.cluster import k_means import numpy as np def calculate_kmeans_inertia ( data : list [ tuple [ int , int ]], n_clusters : int ) -> tuple [ list [ list [ float ]], float ]: # Demo data X = np . array ( data ) centroid , label , inertia = k_means ( X , n_clusters = n_clusters , n_init = "auto" , random_state = 0 ) return centroid . tolist (), inertia Because the input and output types are more complex, we've used a list of tuple of int , int the data input to represent the data matrix. The output is the list of centroids (the numpy array converted to a list) and the inertia value. This demo generates the following C# method signature: public ( IReadOnlyList < IReadOnlyList < double >> , double ) CalculateKmeansInertia ( IReadOnlyList < ( long , long ) > data , long nClusters ); Phi-3 inference demo The phi3_demo.py file contains a demo of using the transformers package from hugging face and pytorch to invoke a Small Language Model (Phi3) and complete an input string. This demo requires the transformers and torch packages to be installed in the Python environment. PyTorch has special requirements and should be installed per the instructions on the PyTorch website . Embedding Python in a .NET Web App The webapp project demonstrates how to embed Python code in a .NET web application. The webapp project is a simple web application that exposes some of the example Python functions via HTTP routes. This demo also comes with a JMeter load test. Made with Material for MkDocs


URL: https://tonybaloney.github.io/CSnakes/faq/
FAQ - CSnakes Skip to content CSnakes FAQ Initializing search GitHub CSnakes GitHub Home Getting Started Reference Environment and Package Management Asynchronous Functions Performance Considerations Buffer Protocol and NumPy Arrays Advanced Usage Limitations FAQ FAQ Table of contents What is the purpose of this project? How does it work? What are the benefits of using CSnakes? How does this compare to IronPython? How does this compare to Python.NET? Do I need to use the source generator? My Python codes uses libraries which have C extensions, will this work? Does this mean I need to type annotate all my Python code? I heard that Python is removing the GIL, does CSnakes handle threads that way? Examples Table of contents What is the purpose of this project? How does it work? What are the benefits of using CSnakes? How does this compare to IronPython? How does this compare to Python.NET? Do I need to use the source generator? My Python codes uses libraries which have C extensions, will this work? Does this mean I need to type annotate all my Python code? I heard that Python is removing the GIL, does CSnakes handle threads that way? Frequently Asked Questions What is the purpose of this project? CSnakes is a .NET Source Generator and Runtime that you can use to embed Python code and libraries into your C#.NET Solution at a performant, low-level without the need for REST, HTTP, or Microservices. How does it work? CSnakes uses the Python C-API to invoke Python code directly from the .NET process. It generates C# code from Python files that are tagged as CSharp Analyzer Additional Files. The generated code includes the function signatures and type conversions based on the type hints in the Python code. See the Getting Started guide for more information. What are the benefits of using CSnakes? Uses native Python type hinting standards to produce clean, readable C# code with minimal boiler plate! Integration between .NET and Python is done at the C-API, meaning strong compatibility between Python versions 3.8-3.12 and .NET 6-8. Integration is low-level and high-performance. CSnakes uses the CPython C-API and is compatible with all Python extensions. Invocation of Python code and libraries is in the same process as .NET How does this compare to IronPython? IronPython is a .NET implementation of Python that runs on the .NET runtime. CSnakes is a tool that allows you to embed Python code and libraries into your C#.NET solution. CSnakes uses the Python C-API to invoke Python code directly from the .NET process, whereas IronPython is a separate implementation of Python that runs on the .NET runtime. How does this compare to Python.NET? There are some similarities, such as Python.NET has a wrapper around the Python C-API. However, CSnakes comes with a Source Generator to create an interop layer automatically between the two platforms and handle the type conversions based on the type hints in the Python code. Do I need to use the source generator? No. You can call Python code without the Source Generator, but you will need to write the boilerplate code yourself. See the Advanced guide for more information. My Python codes uses libraries which have C extensions, will this work? Yes. CSnakes supports C-Extensions and Virtual Environments. You can use the WithPython extension method to specify the path to your Python modules and the .WithVirtualEnvironment() method to load the Python runtime from a virtual environment. Does this mean I need to type annotate all my Python code? No. Just the functions you want to call from C#. The Source Generator will generate the C# code based on the type hints in the Python code. Only the Python files marked in the C# project as CSharp Analyzer Additional Files will be processed. I heard that Python is removing the GIL, does CSnakes handle threads that way? CSnakes supports free-threading mode, but it is disabled by default. You can use the SourceLocator to find a compiled Python runtime with free-threading enabled. See the Advanced guide for more information. Made with Material for MkDocs


URL: https://tonybaloney.github.io/CSnakes/getting-started/
Getting Started - CSnakes Skip to content CSnakes Getting Started Initializing search GitHub CSnakes GitHub Home Getting Started Getting Started Table of contents Configuring a C# Project for CSnakes Installing the NuGet package Adding Python files Marking files for generation Building the project Constructing a Python environment from C Using Virtual Environments and Python Requirements Calling CSnakes code from C#.NET Reference Environment and Package Management Asynchronous Functions Performance Considerations Buffer Protocol and NumPy Arrays Advanced Usage Limitations FAQ Examples Table of contents Configuring a C# Project for CSnakes Installing the NuGet package Adding Python files Marking files for generation Building the project Constructing a Python environment from C Using Virtual Environments and Python Requirements Calling CSnakes code from C#.NET Getting Started To get started with CSnakes, you need to: Install Python Put your Python files into a C# Project Use type annotations for the functions you want to call from C# Install the CSnakes.Runtime package into the project Mark them for source generation Install the CSnakes.Runtime nuget package in the C# Project you want to execute the Python code from Setup a Virtual Environment (Optional) Instantiate a Python environment in C# and run the Python function Configuring a C# Project for CSnakes To setup a C# project for CSnakes, you need to: Create a new C# project or open an existing one. Add your Python files to the project. Mark the Python files as "Additional Files" in the project file. Install the CSnakes.Runtime NuGet package. Create a PythonEnvironment in C# and create an instance of the Python module. Call any Python code. Installing the NuGet package CSnakes is bundled into a single nuget package, CSnakes.Runtime . This package includes the source generator and runtime libraries. Source Generation is recommended for the best experience, but you can also use the runtime library directly if you prefer, see Calling Python without the Source Generator . Adding Python files CSnakes uses the Python type annotations to generate C# code. You need to add Python files to your project and add type annotations to the functions you want to call from C#. For example, if you were to create a Python file called demo.py to your project with the following content: def hello_world ( name : str ) -> str : return f "Hello, { name } !" See the reference supported types for a list of Python types and their C#.NET equivalents. Marking files for generation For CSnakes to run the source generator over Python files, you need to mark the Python file as an "Additional File" in the CSProj file XML: <ItemGroup> <AdditionalFiles Include= "demo.py" > <CopyToOutputDirectory> Always </CopyToOutputDirectory> </AdditionalFiles> </ItemGroup> Or, in Visual Studio change the properties of the file and set Build Action to Csharp analyzer additional file . Building the project After you've added the Python files to the project, installed the NuGet packages, and marked the Python files for generation, you can build the project using dotnet build . Constructing a Python environment from C Python environments created by CSnakes are designed to be process-level singletons. This means that you can create a Python environment once and use it throughout the lifetime of the process. CSnakes comes with a host builder for the Microsoft.Extensions.Hosting library to make it easier to create a Python environment in your C# code. CSnakes also needs to know where to find Python using one or many Python Locators .
The simplest option is the FromRedistributable extension method, which will download Python 3.12 and store it locally. This is compatible with Windows, macOS, and Linux. Here's an example of how you can create a Python environment in C#: using CSnakes.Runtime ; using Microsoft.Extensions.DependencyInjection ; using Microsoft.Extensions.Hosting ; using System ; using System.Collections.Generic ; using System.IO ; using System.Text.Json ; var builder = Host . CreateApplicationBuilder ( args ); var home = Path . Join ( Environment . CurrentDirectory , "." ); /* Path to your Python modules */ builder . Services . WithPython () . WithHome ( home ) . FromRedistributable (); // Download Python 3.12 and store it locally var app = builder . Build (); var env = app . Services . GetRequiredService < IPythonEnvironment > (); Check out the sample project in the samples for code examples of a .NET console application and web application. Using Virtual Environments and Python Requirements Since most Python projects require external dependencies outside of the Python standard library, CSnakes supports execution within a Python virtual environment and Conda environments. Use the .WithVirtualEnvironment method to specify the path to the virtual environment. You can also optionally use the .WithPipInstaller() method to install packages listed in a requirements.txt file in the virtual environment. If you don't use this method, you need to install the packages manually before running the application. var home = Path . Join ( Environment . CurrentDirectory , "." ); /* Path to your Python modules */ builder . Services . WithPython () . WithHome ( home ) . FromRedistributable () /* Add these methods to configure a virtual environment and install packages from requirements.txt */ . WithVirtualEnvironment ( Path . Join ( home , ".venv" )) . WithPipInstaller (); // Optional - installs packages listed in requirements.txt on startup See Environment and Package Management for more information on managing Python environments and dependencies. Calling CSnakes code from C#.NET Once you have a Python environment, you can call any Python function from C# using the IPythonEnvironment interface. Here's an example of how you can call the hello_world function from the demo.py file: var env = app . Services . GetRequiredService < IPythonEnvironment > (); var module = env . Demo (); var result = module . HelloWorld ( "Alice" ); Console . WriteLine ( result ); // Hello, Alice! Check out the reference for more information on supported types and features. Made with Material for MkDocs


URL: https://tonybaloney.github.io/CSnakes/limitations/
Limitations - CSnakes Skip to content CSnakes Limitations Initializing search GitHub CSnakes GitHub Home Getting Started Reference Environment and Package Management Asynchronous Functions Performance Considerations Buffer Protocol and NumPy Arrays Advanced Usage Limitations Limitations Table of contents Type Hinting Variadic Generics Union Types Classes Async functions FAQ Examples Table of contents Type Hinting Variadic Generics Union Types Classes Async functions Limitations This is a list of known limitations. If you really want to see any of these, or other features please raise an issue and describe your use case. Type Hinting Variadic Generics C# does not have a notion of Tuple<T...> , so the type annotation using Tuple[*T] in Python cannot be statically converted into a C#.NET type. See PEP646 for more details and 25 . Union Types Python's type hinting supports Union types, which are not supported in C#.NET. This includes both typing.Union and the union operator described in PEP 604 . Classes CSnakes does not support source generation for custom types, this includes dataclasses and named tuple instances. Functions which return class instances will return a PyObject in C#.NET which you can use to pass into other functions. This type is a reference to the return value. def create_person ( name : str , age : int ) -> Person : return Person ( name , age ) CSnakes will create a method signature like this: public PyObject CreatePerson ( string name , long age ); There are some public methods on the PyObject class that you can use to interact with the object, such as GetAttr and Call .
Any PyObject has a ToString() method that will return the string representation of the object, but you cannot convert the instance to a specific CLR type. var person = module . CreatePerson ( "Alice" , 42 ); var name = person . GetAttr ( "name" ); var age = person . GetAttr ( "age" ); Async functions Python coroutines declared using the async syntax are not supported. If you would like this feature, please raise an issue . Made with Material for MkDocs


URL: https://tonybaloney.github.io/CSnakes/performance/
Performance Considerations - CSnakes Skip to content CSnakes Performance Considerations Initializing search GitHub CSnakes GitHub Home Getting Started Reference Environment and Package Management Asynchronous Functions Performance Considerations Performance Considerations Table of contents Important Concepts 3 Things to avoid when performance matters 1. "Crossing the bridge" too frequently 2. Marshalling return values unnecessarily Tuples are value types Lazy dictionaries Lazy lists 3. Sending large amounts of data to Python Using bytes Using numpy arrays Streaming data from Python into .NET Buffer Protocol and NumPy Arrays Advanced Usage Limitations FAQ Examples Table of contents Important Concepts 3 Things to avoid when performance matters 1. "Crossing the bridge" too frequently 2. Marshalling return values unnecessarily Tuples are value types Lazy dictionaries Lazy lists 3. Sending large amounts of data to Python Using bytes Using numpy arrays Streaming data from Python into .NET Performance Optimal performance is one of the key design principles of CSnakes. That
said, there are some important differences between Python and .NET which impact
performance when embedding. This page documents some performance considerations when using CSnakes. Important Concepts Marshalling refers to the transfer of data and types between platforms
  (Python to .NET or .NET to Python). For example converting a Python int into
  a C#.NET long . 3 Things to avoid when performance matters 1. "Crossing the bridge" too frequently Python and .NET functions have very different calling conventions. Whilst every
effort has been made to make calling Python functions fast from .NET in CSnakes,
function calls are relatively slow compared with regular .NET to .NET calls.
Function calling in Python is generally slow (compared to C#, C++, Rust, C,
etc.) so when writing performance Python code you should avoid writing tiny
functions and making too many calls. Python doesn't have function inlining
(unlike C# with JIT or AOT compilation) and a lot of CPU time is spent creating
call frames. Calling Python functions from CSnakes is slower than calling Python functions
from Python, because CSnakes has to marshal the input values from .NET into
Python objects and vice versa. Therefore, you want to avoid "crossing the
bridge" (going between .NET and Python) too frequently. For example, take this code: import numpy as np def make_square_2d_array ( n : int ) -> np . ndarray : return np . zeros (( n , n )) def set_random ( arr , i : int , j : int ) -> None : arr [ i , j ] = np . random . random () From C#, you fill or set the values in the array like this: var names = env . Make2dArray ( 1000 ); for ( int i = 0 ; i < 1000 ; i ++ ) { for ( int j = 0 ; j < 1000 ; j ++ ) { env . SetRandom ( names , i , j ); } } This is a very inefficient way to set the values in the array. The SetRandom function is called 1,000,000 times and each time it crosses the
bridge between .NET and Python. For all 1,000,000 calls, the C# integers i and j are converted to Python integers, the function is called, and then the
result is converted back. Instead, you should design your code with a wrapper function to minimize the
number of interop calls. For example, you could create a function that sets all
the values in the array at once: def set_random ( arr : np . ndarray ) -> None : for i in range ( arr . shape [ 0 ]): for j in range ( arr . shape [ 1 ]): arr [ i , j ] = np . random . random () 2. Marshalling return values unnecessarily Unlike .NET which has value types and reference types, Python has only names
which are references to objects (everything is a pointer to PyObject ). If you're a C# developer, just think of Python
as having only reference types. To marshall value types from .NET to Python, CSnakes has to convert the value
type into a reference type. This is done by creating a new object in Python and
copying the value into it. This is a relatively expensive operation and should
be avoided when possible. There are some performance tricks in CSnakes to intern
certain values like 0 , 1 , True , False , and None to avoid this
overhead, but you should still be careful when passing value types to Python
functions. If you don't need to read the return value of a Python function, you can hint
the function as Any . This will tell the source generator to return a PyObject , which is a SafeHandle to the Python object. This will avoid the
overhead of marshalling the return value into a .NET type. This is particularly useful when passing data between functions. For example, if the Python function a returns an object and you need that to
pass to another function b , you can do this: def a (): return ... def b ( x : ... ) -> None : # Do something with x pass Instead of marshalling the return value of a into a .NET type, you can use Any to avoid the overhead: def a () -> Any : return ... Then from C#, you use the PyObject type to pass the value to the next
function: using CSnakes.Runtime ; var pyObj = env . A (); env . B ( pyObj ); Tuples are value types In .NET, Tuple types are value types; tuple elements are public fields. Unlike
Python, where tuples are immutable and returned as a reference (pointer to PyObject ). This means that if
a Python object returns a tuple, each of the elements in the tuple is eagerly
marshalled into the corresponding .NET type. That is different to dictionaries and lists, which are lazily marshalled (see
below). Lazy dictionaries If a Python function returns a dictionary, CSnakes will return IReadOnlyDictionary with an implementation to lazily convert the values to
.NET types. The conversion is completed the first time the key value is accessed. Lazy Conversion is done to avoid the overhead of converting all the values in
the dictionary to .NET types when the dictionary is created. IReadOnlyDictionary < string , int > dict = env . ExampleDict (); // Don't do this to get the value of a key foreach ( var kvp in dict ) { if ( kvp . Key == "key" ) { // Do something with the value int value = kvp . Value ; } } // Instead, check the existence of a key if ( dict . ContainsKey ( "key" )) { // Get the value of the key int value = dict [ "key" ]; } Lazy lists Similar to dictionaries, if a Python function returns a list, CSnakes will
return IReadOnlyList with an implementation to lazily convert the values to
.NET types as each index is accessed. Where possible, you should try and avoid iterating over the list to get a single
or a few values. Instead, you should use the IReadOnlyList interface to index
into the specific values you need. If you do, the marshalled value is cached in the IReadOnlyList implementation.
This means that if you call the same index multiple times, the value is only
marshalled once. 3. Sending large amounts of data to Python Whilst Python functions which return lists and dictionaries are lazily
marshalled, functions which take lists and dictionaries as arguments are not;
they are copied instead. This means that if you pass a large list or dictionary
to a Python function, CSnakes has to eagerly marshal the entire list or
dictionary into .NET types. Take this example: def example_function ( data : list [ int ]) -> None : # Do something with the data pass From C#, you can call this function like this: env . ExampleFunction ([ 1 , 2 , 3 ]); When calling the Python function, CSnakes has to create a Python list object and
create a Python integer object for each element in the list. If there are
thousands or millions of elements in the list, this can be a very expensive
operation. There are some alternatives: Using bytes If you are passing a large amount of data to Python, you can use a bytes instead of a list. This will avoid the overhead of creating a Python list and
converting each element to a Python object. from array import array def example_function ( data : bytes ) -> None : # Do something with the data arr = array ( 'B' , data ) # unsigned char # Do something with the array From C#, you can call this function like this: byte [] data = new byte [ 1 _000_000 ]; for ( int i = 0 ; i < data . Length ; i ++ ) // Fill the byte array with data (example) { data [ i ] = ( byte ) i ; } env . ExampleFunction ( data ); CSnakes only creates 1 Python object and copies the byte array into the bytes object. This is more efficient than creating an array or tuple of values, because each of the elements in the array needs to be created as a Python object and allocated. You can use the array module to convert the bytes into a list of an underlying C type. Using numpy arrays If you're sending large byte data, or numerical data from Python to .NET, you
should use the Buffer protocol to pass the data. If you need to copy lots of numerical data from .NET to Python, we recommend
creating a numpy array in Python and using the Buffer type to fill
it from .NET. This is the fastest way to pass large amounts of data to Python. You can combine generators with the Buffer type to yield the empty Numpy
array, fill it from .NET, the continue with execution in Python: import numpy as np from typing import Generator from collections.abc import Buffer def sum_of_2d_array ( n : int ) -> Generator [ Buffer , None , int ]: arr = np . zeros (( n , n ), dtype = np . int32 ) yield arr return np . sum ( arr ) . item () From C#, you can call the generator, wait for the first yield, and then fill the
array with data from .NET: // whatever your data looks like, e.g. a list of Int32 List < Int32 > list = new () { 1 , 2 , 3 , 4 , 5 }; var bufferGenerator = testModule . SumOf2dArray ( 5 ); // Move to the first yield bufferGenerator . MoveNext (); // Get the buffer object var bufferObject = bufferGenerator . Current ; // Get the buffer as a 2D span of Int32 var bufferAsSpan = bufferObject . AsInt32Span2D (); // Copy the list to the buffer for ( int i = 0 ; i < list . Count ; i ++ ) { for ( int j = 0 ; j < list . Count ; j ++ ) { bufferAsSpan [ i , j ] = list [ i ]; } } // Continue execution in Python bufferGenerator . MoveNext (); // Get return value long result = bufferGenerator . Return ; Streaming data from Python into .NET If you need to send lots of data from Python to .NET, you can either use the buffer protocol or use a generator to stream the data from Python to
.NET. Made with Material for MkDocs


URL: https://tonybaloney.github.io/CSnakes/reference/
Reference - CSnakes Skip to content CSnakes Reference Initializing search GitHub CSnakes GitHub Home Getting Started Reference Reference Table of contents Supported Types Return types Default values Handling None Object comparisons Python Locators Redistributable Locator Environment Variable Locator Folder Locator Source Locator MacOS Installer Locator Windows Installer Locator Windows Store Locator Nuget Locator Conda Locator Parallelism and concurrency Implementation details GIL and multi-threading Exceptions Fetching stack traces Generators Running any Python code Environment and Package Management Asynchronous Functions Performance Considerations Buffer Protocol and NumPy Arrays Advanced Usage Limitations FAQ Examples Table of contents Supported Types Return types Default values Handling None Object comparisons Python Locators Redistributable Locator Environment Variable Locator Folder Locator Source Locator MacOS Installer Locator Windows Installer Locator Windows Store Locator Nuget Locator Conda Locator Parallelism and concurrency Implementation details GIL and multi-threading Exceptions Fetching stack traces Generators Running any Python code Reference Supported Types CSnakes supports the following typed scenarios: Python type annotation Reflected C# Type int long float double str string bytes byte[] bool bool list[T] IReadOnlyList<T> dict[K, V] IReadOnlyDictionary<K, V> tuple[T1, T2, ...] (T1, T2, ...) typing.Sequence[T] IReadOnlyList<T> typing.Dict[K, V] IReadOnlyDictionary<K, V> typing.Mapping[K, V] IReadOnlyDictionary<K, V> typing.Tuple[T1, T2, ...] (T1, T2, ...) typing.Optional[T] T? T \| None T? typing.Generator[TYield, TSend, TReturn] IGeneratorIterator<TYield, TSend, TReturn> 1 typing.Buffer IPyBuffer 2 typing.Coroutine[TYield, TSend, TReturn] Task<TYield> 3 None (Return) void Return types The same type conversion applies for the return type of the Python function, with the additional feature that functions which explicitly return type None are declared as void in C#. Default values CSnakes will use the default value for arguments of types int , float , str , and bool for the generated C# method. For example, the following Python code: def example ( a : int = 123 , b : bool = True , c : str = "hello" , d : float = 1.23 ) -> None ... Will generate the following C#.NET method signature: public void Example ( long a = 123 , bool b = true , string c = "hello" , double d = 1.23 ) CSnakes will treat =None default values as nullable arguments. The Python runtime will set the value of the parameter to the None value at execution. Handling None If you need to send None as a PyObject to any function call from C#, use the property PyObject.None : env . MethodToCall ( PyObject . None ); You can also check if a PyObject is None by calling IsNone() on any PyObject: PyObject obj = env . MethodToCall (); if ( obj . IsNone ()) { Console . WriteLine ( "The object is None" ); } Object comparisons The PyObject types can be compared with one another using the is , == and != operators from Python. The equivalent to the x is y operator in Python is : // Small numbers are the same object in Python (weird implementation detail) PyObject obj1 = PyObject . From ( true ); PyObject obj2 = PyObject . From ( true ); if ( obj1 ! . Is ( obj2 )) Console . WriteLine ( "Objects are the same!" ); Equality can be accessed from the .Equals method or using the == operators in C#: PyObject obj1 = PyObject . From ( 3.0 ); PyObject obj2 = PyObject . From ( 3 ); if ( obj1 == obj2 ) Console . WriteLine ( "Objects are equal!" ); Inequality can be accessed from the .NotEquals method or using the != operators in C#: PyObject obj1 = PyObject . From ( 3.0 ); PyObject obj2 = PyObject . From ( 3 ); if ( obj1 != obj2 ) Console . WriteLine ( "Objects are not equal!" ); Python Locators CSnakes uses a PythonLocator to find the Python runtime on the host machine. The PythonLocator is a service that is registered with the dependency injection container and is used to find the Python runtime on the host machine. You can chain locators together to match use the first one that finds a Python runtime. This is a useful pattern for code that is designed to run on Windows, Linux, and MacOS. The simplest and most user-friendly locator is the Redistributable Locator. This will fetch and run Python for you. Redistributable Locator The .FromRedistributable() method automates the installation of a compatible version of Python. It will source Python and cache it locally. This download is about 50-80MB, so the first time you run your application, it will download the redistributable and cache it locally. The next time you run your application, it will use the cached redistributable. This could take a minute or two depending on your bandwidth. By default, Python 3.12 will be used. You can specify a different major version of Python: ... var pythonBuilder = services . WithPython () . FromRedistributable ( "3.13" ); You can also request debug builds on macOS and Linux to aid with debugging of crashes in native extensions: ... var pythonBuilder = services . WithPython () . FromRedistributable ( "3.13" , debug : true ); Or, if you want to experiment with free-threaded builds of Python, the free-threaded build for Python 3.13+: ... var pythonBuilder = services . WithPython () . FromRedistributable ( "3.13" , debug : true , freeThreaded : true ); Environment Variable Locator The .FromEnvironmentVariable() method allows you to specify an environment variable that contains the path to the Python runtime. This is useful for scenarios where the Python runtime is installed in a non-standard location or where the path to the Python runtime is not known at compile time. This locator is also very useful for GitHub Actions setup-python actions, where the Python runtime is installed in a temporary location specified by the environment variable " Python3_ROOT_DIR ": ... var pythonBuilder = services . WithPython () . FromEnvironmentVariable ( "Python3_ROOT_DIR" , "3.12" ); Folder Locator The .FromFolder() method allows you to specify a folder that contains the Python runtime. This is useful for scenarios where the Python runtime is installed in a known location on the host machine. ... var pythonBuilder = services . WithPython () . FromFolder ( @"C:\path\to\python\3.12" , "3.12" ); Source Locator The Source Locator is used to find a compiled Python runtime from source. This is useful for scenarios where you have compiled Python from source and want to use the compiled runtime with CSnakes. It optionally takes a bool parameter to specify that the binary is debug mode and to enable free-threading mode in Python 3.13: ... var pythonBuilder = services . WithPython () . FromSource ( @"C:\path\to\cpython\" , "3.13" , debug : true , freeThreaded : true ); MacOS Installer Locator The MacOS Installer Locator is used to find the Python runtime on MacOS. This is useful for scenarios where you have installed Python from the official Python installer on MacOS from python.org . ... var pythonBuilder = services . WithPython () . FromMacOSInstaller ( "3.12" ); Windows Installer Locator The Windows Installer Locator is used to find the Python runtime on Windows. This is useful for scenarios where you have installed Python from the official Python installer on Windows from python.org . ... var pythonBuilder = services . WithPython () . FromWindowsInstaller ( "3.12" ); Windows Store Locator The Windows Store Locator is used to find the Python runtime on Windows from the Windows Store. This is useful for scenarios where you have installed Python from the Windows Store on Windows. ... var pythonBuilder = services . WithPython () . FromWindowsStore ( "3.12" ) Nuget Locator The Nuget Locator is used to find the Python runtime from a Nuget package. This is useful for scenarios where you have installed Python from one of the Python Nuget packages found at nuget.org . These packages only bundle the Python runtime for Windows. You also need to specify the minor version of Python: ... var pythonBuilder = services . WithPython () . FromNuGet ( "3.12.4" ); Conda Locator The Conda Locator is used to find the Python runtime from a Conda environment. This is useful for scenarios where you have installed Python from the Anaconda or miniconda distribution of Python. Upon environment creation, CSnakes will run conda info --json to get the path to the Python runtime. This Locator should be called with the path to the Conda executable: ... var pythonBuilder = services . WithPython () . FromConda ( @"C:\path\to\conda" ); The Conda Locator should be combined with the WithCondaEnvironment method to specify the name of the Conda environment you want to use. See Environment and Package Management for more information on managing Python environments and dependencies. Parallelism and concurrency CSnakes is designed to be thread-safe and can be used in parallel execution scenarios. See Advanced Usage for more information on using CSnakes in a multi-threaded environment. Implementation details CSnakes uses the Python C-API to invoke Python code from C#. The Python C-API is a low-level interface to the Python runtime that allows you to interact with Python objects and execute Python code from C. CSnakes generates a C# class that handles the calls and conversions between Python and C#. The generated class is a wrapper around the Python C-API that allows you to call Python functions and methods from C#. The generated class uses the Python.Runtime library to interact with the Python C-API. The Python.Runtime library is a C# wrapper around the Python C-API that provides a high-level interface to the Python runtime. The PyObject type is a Managed Handle to a Python object. It is a reference to a Python object that is managed by the Python runtime. The PyObject type is used to pass Python objects around inside C#. All PyObject instances have been created with a strong reference in C#. They are automatically garbage collected when the last reference is released. These objects are also disposable, so you can release the reference manually if you need to: using CSnakes.Runtime.Python ; { using PyObject obj = env . MethodToCall (); Console . WriteLine ( obj . ToString ()); } // obj is disposed here GIL and multi-threading CSnakes uses the Python Global Interpreter Lock (GIL) to ensure that only one thread can execute Python code at a time. This is necessary because the Python runtime is not thread-safe and can crash if multiple threads try to execute Python code simultaneously. All public methods generate by CSnakes have a built-in GIL acquisition and release mechanism. This means that you can safely call Python functions from multiple threads without worrying about the GIL. Exceptions CSnakes will raise a PythonInvocationException if an error occurs during the execution of the Python code. The PythonInvocationException class contains the error message from the Python interpreter as the InnerException . If the annotations are incorrect and your Python code returns a different type to what CSnakes was expecting, an InvalidCastException will be thrown with the details of the source and destination types. Fetching stack traces You can fetch the Python stack trace as well as the Globals and Locals of the top frame by getting the InnerException attribute of the raised PythonInvocationException : try { env . MethodToCall (); } catch ( PythonInvocationException ex ) { Console . WriteLine ( ex . PythonExceptionType ); // E.g. ValueError Console . WriteLine ( ex . InnerException . PythonStackTrace ); // IEnumerable<string> with the complete stack trace Console . WriteLine ( ex . InnerException . Data [ "locals" ]); // Dictionary <string, PyObject> Console . WriteLine ( ex . InnerException . Data [ "globals" ]); // Dictionary <string, PyObject> } Generators CSnakes supports Python generators using the typing.Generator type annotation. The typing.Generator type annotation is used to specify a generator function that yields values of a specific type. CSnakes will convert a Python Generator to a CLR type in the CSnakes.Runtime.Python namespace that implements the IGeneratorIterator interface. The IGeneratorIterator implements both IEnumerable<T> and IEnumerator<T> interfaces, so you can use it in foreach loops and LINQ queries. For example the Python function: from typing import Generator def example_generator ( length : int ) -> Generator [ str , int , bool ]: for i in range ( length ): x = yield f "Item { i } " if x : yield f "Received { x } " return True Will return a IGeneratorIterator<string, long, bool> . You can use this in a C# foreach loop: var generator = env . ExampleGenerator ( 5 ); foreach ( string item in generator ) { Console . WriteLine ( item ); } IGeneratorIterator also implements a Send method that allows you to send values back into the generator. The type of .Send is the TSend type parameter of the Generator type annotation and returns TYield . In the example above, the TSend type is long , so you can send a long value back into the generator: var generator = env . ExampleGenerator ( 5 ); string nextValue = generator . Send ( 10 ); Running any Python code Sometimes you may want to run Python code that doesn't have type annotations or is not part of a module. You can use the Run method on the IPythonEnvironment to execute any Python code. Python has two ways to do, this "expressions" and "statements". Expressions return a value and are a single line. You can use the ExecuteExpression method to run an expression and get the result back: env . ExecuteExpression ( "1+1" ). As < int > () ; // 2 You can pass a dictionary of local and/or global variables: var locals = new Dictionary < string , PyObject > { ["a"] = PyObject . From ( 101 ) }; using var result = env . ExecuteExpression ( "a+1" , locals ); // 102 To execute a series of statements, you can use the Execute method, which also takes globals and locals: var c = """ a = 101 b = c + a """; var locals = new Dictionary < string , PyObject > { ["c"] = PyObject . From ( 101 ) }; var globals = new Dictionary < string , PyObject > { ["d"] = PyObject . From ( 100 ) }; using var result = env . Execute ( c , locals , globals ); Made with Material for MkDocs

